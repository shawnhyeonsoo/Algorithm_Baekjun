[Baekjun Online Judge 7569번: 토마토] </br>
출처: 백준 온라인 저지</br>
문제 링크: <https://www.acmicpc.net/problem/7569> </br>



문제 </br>
</br>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다. </br>

![image](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/tomato.png)

창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.
</br>
입력</br>
첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다. </br>

</br>출력</br>
여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</br>

</br>
</br>
솔루션:</br>

```python
import sys
from collections import deque

def BFS(total,ripe_list):
    dx = [1,-1,0,0,0,0]
    dy = [0,0,1,-1,0,0]
    dz = [0,0,0,0,1,-1]
    count = -1
    while ripe_list:
        for _ in range(len(ripe_list)):
            ripe = ripe_list.popleft()
            ripex = ripe[0]
            ripey = ripe[1]%N
            ripez = ripe[1]//N
            for k in range(6):
                mx = ripex + dx[k]
                my = ripey + dy[k]
                mz = ripez + dz[k]
                if (0<= mx < M) and (0<= my < N) and (0<= mz < H) and total[(N*mz)+my][mx] == 0:
                    total[(N * mz) + my][mx] = 1
                    ripe_list.append((mx,(N*mz)+my))
        count += 1

    for b in total:
        if 0 in b:
            return -1
    return count

M, N, H = map(int,sys.stdin.readline().split())
ripe_list = deque()
total = []
for i in range(N*H):
    B = list(map(int,sys.stdin.readline().split()))
    for j in range(M):
        if B[j] == 1:
            ripe_list.append((j,i))
    total.append(B)

print(BFS(total,ripe_list))
```
</br> 

> 앞서 풀었던 토마토 (7576번) 의 3차원 버젼의 문제인데, 전에는 한층의 토마토 상자만 있었다면, 이 문제에서는 더 많은 층의 토마토 상자가 있으며, 익은 토마토가
  기존 4방향에서 위와 아래 방향까지 추가해 총 6가지 방향으로 영향을 줄 수 있다는 조건이다. 3차원으로 해결하고자 ripe_list를 [x,y,z] 방식으로 3가지 차원의
  주소를 구해 저장하고 함수를 실행시켰는데, 답은 나오지만 채점에서는 런타임 에러가 나왔다. 세로 주소(y)만으로 높이 주소(z)를 구할 수 있었는데, 첫 입력시 주어지는
  상자의 세로 칸 수(N)로 나눈 몫과 나머지로 구할 수 있었다. 그 후 while문을 통해 익은 토마토를 앞에서부터 빼주며 뒤에는 해당 토마토로 인해 익은 토마토의 주소를
  주면서 전체 상자들의 주소를 다 돌 수 있도록 했다. 비록 답은 맞았지만, 소요 시간과 메모리가 크게 나와 크게 효율적이라고는 못할 것 같다. '0'이 주어지는 주소에
  이웃 4칸과 위아래로 '-1'이 있다면 해당 토마토는 익을 수가 없기 때문에 3차원 배열 전체에서 '0'을 찾는 대신 이로부터 바로 '-1' 을 출력하도록 할 수 없을까
  생각중인데, 다시 구현해봐야 할 것 같다. 


메모리: 52180KB
시간: 3740ms
