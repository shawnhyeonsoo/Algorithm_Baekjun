[Baekjun Online Judge 1931번: 회의실 배정] </br>
출처: 백준 온라인 저지</br>
문제 링크: <https://www.acmicpc.net/problem/1931> </br>



문제 </br>
</br>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. </br>
</br>
입력</br>
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2<sup>31</sup>-1보다 작거나 같은 자연수 또는 0이다. </br>

</br>출력</br>
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.</br>

</br>
</br>
솔루션:</br>

```python

N = int(input())
A = []
B = []
count = 0
for i in range(N):
    start,end = map(int,input().split())
    A.append((start,end))

A = sorted(A, key=lambda A: (A[1],A[0]))

for j in range(len(A)):
    if len(B) == 0:
        B.append(A[j])
        count += 1
    elif A[j][0] >= B[-1][1]:
        B.append(A[j])
        count +=1
    else:
        pass

print(count)
```
</br> 

> Greedy Algorithm 그리디 알고리즘 구현에 대한 문제이다. 사실 문제를 푸는 것에 있어서 그리디 알고리즘을 구현해야 한다는 것도 알고 있었고, 구현 방법은 알고
  있었다고 생각했지만, 막상 회의의 시작시간, 끝시간으로 알고리즘 구현을 하는 것에 어려움을 겪었다. 가장 뒤에서부터 시간을 채우는 방법도 써보고 여러 방법을
  생각해봤지만, 어려움이 있었다. 그러다가 공부를 하면서 sorted( ,key = lambda : ()) 식으로 tuple 형식의 데이터를 특정 값에 대해 정렬이 가능하다는 것을
  알게 되었고, 이를 참고해서 끝 시간, 시작 시간 순으로 정렬한 다음 문제 내용대로 겹치는 회의는 무시하고 안겹치는 회의가 생길 때마다 count를 증가시켜
  함수값을 프린트할 수 있도록 했다. 이 문제를 풀면서 기존에 알고 있던 sorted의 심화 버젼으로 보이는 sorted( ,key = lambda: ()) 함수를 알게 되었고,
  앞으로 큰 도움이 될 것 같다.

메모리: 50548KB
시간: 4168ms
